import AuthHelper from "../src/index";
import dayjs from "dayjs";

const access_token = "this_is_a_long_access_token-for!test";
const token_type = "test";
const refresh_token = "this_is_another_long_access_token-for!test";
const scope = "ALL";

describe("Basic methods test", () => {
  describe("Test for set token and get token", () => {
    it("Test for normal get and set", () => {
      AuthHelper.setToken({
        access_token: access_token,
        token_type: token_type,
        expires_in: 120,
        refresh_token: refresh_token,
        scope: scope
      });

      const { token } = AuthHelper.getAuthState();
      expect(token).not.toBeUndefined();

      if (token !== undefined) {
        expect(token.access_token).toBe(access_token);
        expect(token.token_type).toBe(token_type);
        expect(token.expires_in).toBe(120);
        expect(token.refresh_token).toBe(refresh_token);
        expect(token.scope).toBe(scope);
      }
    });

    it("Test for handle undefined", () => {
      AuthHelper.clearAuthState();
      const { token } = AuthHelper.getAuthState();
      expect(token).toBeUndefined();
    });

    it("Test for optional token params", () => {
      AuthHelper.setToken({
        access_token: access_token,
        token_type: token_type,
        expires_in: 120
      });

      const { token } = AuthHelper.getAuthState();
      expect(token).not.toBeUndefined();

      if (token !== undefined) {
        expect(token.refresh_token).toBeUndefined();
        expect(token.scope).toBeUndefined();
        expect(token.access_token).toBe(access_token);
      }
    });
  });

  describe("Test for set auth info and get auth info", () => {
    const infoObject = {
      username: "username",
      auth: {
        article: ["read", "write"]
      },
      level: 1000,
      role: ["student", "teacher"]
    };

    it("Test for normal get and set", () => {
      AuthHelper.setAuthData(infoObject);

      let { authData } = AuthHelper.getAuthState();
      expect(authData).not.toBeUndefined();

      if (authData !== undefined) {
        expect(authData).toEqual(infoObject);
      }

      AuthHelper.setAuthData({});
      authData = AuthHelper.getAuthState().authData;
      expect(authData).not.toBeUndefined();
      if (authData !== undefined) {
        expect(authData).toEqual({});
      }
    });
  });

  it("Test for clear authData", () => {
    const tokenData = {
      access_token: access_token,
      token_type: token_type,
      expires_in: 120,
      refresh_token: refresh_token,
      scope: scope
    };

    AuthHelper.setToken(tokenData);
    AuthHelper.setAuthData({ key: "value" });

    const authState = AuthHelper.getAuthState();
    expect(authState.token).toEqual(tokenData);
    expect(authState.authData).toEqual({ key: "value" });

    AuthHelper.clearAuthState();
    const { token, authData } = AuthHelper.getAuthState();
    expect(token).toBeUndefined();
    expect(authData).toBeUndefined();
  });

  describe("Test for derived loginState", () => {
    beforeEach(AuthHelper.clearAuthState);

    it("Derived FALSE when has no token", () => {
      expect(AuthHelper.getAuthState().isLogin).toBe(false);
    });

    it("Derived TRUE after setToken", () => {
      const tokenData = {
        access_token: access_token,
        token_type: token_type,
        expires_in: 120,
        refresh_token: refresh_token,
        scope: scope
      };

      AuthHelper.setToken(tokenData);
      expect(AuthHelper.getAuthState().isLogin).toBe(true);
    });

    it("Derived FALSE after setToken and clearToken", () => {
      const tokenData = {
        access_token: access_token,
        token_type: token_type,
        expires_in: 120,
        refresh_token: refresh_token,
        scope: scope
      };

      AuthHelper.setToken(tokenData);

      expect(AuthHelper.getAuthState().isLogin).toBe(true);

      AuthHelper.clearAuthState();
      expect(AuthHelper.getAuthState().isLogin).toBe(false);
    });
  });
});

describe("Expire methods test", () => {
  beforeEach(AuthHelper.clearAuthState);
  const tokenData = {
    access_token: access_token,
    token_type: token_type,
    expires_in: 120,
    refresh_token: refresh_token,
    scope: scope
  };

  it("Test for expire date", () => {
    AuthHelper.setToken(tokenData);
    const currentTime = dayjs();
    const { token } = AuthHelper.getAuthState();
    expect(token).not.toBeUndefined();

    if (token !== undefined && token.expire) {
      const shouldExpireDate = +currentTime.add(120, "second").toDate();
      const tokenExpire = +token.expire;

      expect(shouldExpireDate - tokenExpire).toBeLessThanOrEqual(100);
    }
  });

  describe("Test for isExpired Methods", () => {
    jest.useFakeTimers();

    it("Expired should be FALSE in 1 seconds", () => {
      AuthHelper.setToken(tokenData);
      const beginTime = +dayjs()
        .add(1, "second")
        .toDate();

      const { token } = AuthHelper.getAuthState();
      expect(token).not.toBeUndefined();
      if (token !== undefined && token.expire) {
        setTimeout(() => {
          const currentTime = +dayjs().toDate();
          expect(beginTime - currentTime).toBeLessThanOrEqual(10);
          expect(AuthHelper.isExpired(token)).toBe(false);
        }, 1000);
      }
    });

    it("Expired should be TRUE in 61 seconds", () => {
      AuthHelper.setToken(tokenData);
      const beginTime = +dayjs()
        .add(61, "second")
        .toDate();

      const { token } = AuthHelper.getAuthState();
      expect(token).not.toBeUndefined();
      if (token !== undefined && token.expire) {
        setTimeout(() => {
          const currentTime = +dayjs().toDate();
          expect(beginTime - currentTime).toBeLessThanOrEqual(10);
          expect(AuthHelper.isExpired(token)).toBe(true);
        }, 61000);
      }
    });
  });
});

describe("Test for customize storage keys", () => {
  const defaultTokenKey = "USER_AUTH_TOKEN";
  const defaultInfoKey = "USER_AUTH_INFO";
  afterEach(() => {
    AuthHelper.setKeys({ tokenKey: defaultTokenKey, infoKey: defaultInfoKey });
    expect(AuthHelper.tokenKey).toBe(defaultTokenKey);
    expect(AuthHelper.infoKey).toBe(defaultInfoKey);
  });

  it("Test for default keys", () => {
    expect(AuthHelper.tokenKey).toBe(defaultTokenKey);
    expect(AuthHelper.infoKey).toBe(defaultInfoKey);
  });

  it("Test for set Keys", () => {
    expect(AuthHelper.tokenKey).toBe(defaultTokenKey);
    expect(AuthHelper.infoKey).toBe(defaultInfoKey);

    AuthHelper.setKeys({ tokenKey: "TOKEN", infoKey: "INFO" });
    expect(AuthHelper.tokenKey).toBe("TOKEN");
    expect(AuthHelper.infoKey).toBe("INFO");
  });

  describe("Test for optional params", () => {
    it("Test for nope params", () => {
      AuthHelper.setKeys();
      expect(AuthHelper.tokenKey).toBe(defaultTokenKey);
      expect(AuthHelper.infoKey).toBe(defaultInfoKey);
    });

    it("Test for nope token Key", () => {
      AuthHelper.setKeys({ infoKey: "INFO" });
      expect(AuthHelper.tokenKey).toBe(defaultTokenKey);
      expect(AuthHelper.infoKey).toBe("INFO");
    });

    it("Test for nope info key", () => {
      AuthHelper.setKeys({ tokenKey: "TOKEN" });
      expect(AuthHelper.tokenKey).toBe("TOKEN");
      expect(AuthHelper.infoKey).toBe(defaultInfoKey);
    });
  });

  describe("Test for handle same keys", () => {
    beforeEach(() => {
      AuthHelper.setKeys({ tokenKey: "TOKEN", infoKey: "INFO" });
    });
    it("Handle same keys in params", () => {
      expect(() => {
        AuthHelper.setKeys({ tokenKey: "KEY", infoKey: "KEY" });
      }).toThrow();

      expect(AuthHelper.tokenKey).toBe("TOKEN");
      expect(AuthHelper.infoKey).toBe("INFO");
    });

    it("Handle set new key when existing same key", () => {
      expect(() => {
        AuthHelper.setKeys({ infoKey: "TOKEN" });
      }).toThrow();

      expect(() => {
        AuthHelper.setKeys({ tokenKey: "INFO" });
      }).toThrow();

      expect(AuthHelper.tokenKey).toBe("TOKEN");
      expect(AuthHelper.infoKey).toBe("INFO");
    });

    it("Allow exchange key", () => {
      AuthHelper.setKeys({ tokenKey: "INFO", infoKey: "TOKEN" });
      expect(AuthHelper.tokenKey).toBe("INFO");
      expect(AuthHelper.infoKey).toBe("TOKEN");
    });
  });
});
